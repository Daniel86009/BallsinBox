<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multiplayer Spawner</title>
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        body { font-family: system-ui, sans-serif; text-align: center; background: #0f172a; color: white; margin: 0; overflow: hidden; }
        #controls { position: absolute; top: 10px; left: 10px; z-index: 10; background: rgba(15, 23, 42, 0.9); padding: 15px; border-radius: 12px; text-align: left; border: 1px solid #334155; }
        canvas { display: block; background: #020617; }
        input { padding: 8px; border-radius: 6px; border: 1px solid #334155; background: #1e293b; color: white; margin-bottom: 8px; width: 140px; }
        button { padding: 8px 12px; border-radius: 6px; border: none; cursor: pointer; font-weight: bold; transition: 0.2s; }
        .btn-host { background: #10b981; color: white; }
        .btn-join { background: #3b82f6; color: white; }
        #status { font-size: 0.8em; margin-top: 10px; color: #94a3b8; }
        .hint { font-size: 0.75em; color: #64748b; margin-top: 5px; }
    </style>
</head>
<body>

<div id="controls">
    <input type="text" id="peerCode" placeholder="Room Code" value="ball-room-1"> <br>
    <button class="btn-host" onclick="startHosting()">Host Room</button>
    <button class="btn-join" onclick="joinRoom()">Join Room</button>
    <div id="status">Status: Offline</div>
    <div class="hint">Click anywhere to spawn a ball!</div>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const statusDiv = document.getElementById('status');
    const codeInput = document.getElementById('peerCode');

    let peer = null;
    let conn = null;
    let isHost = false;
    let isConnected = false;
    let circles = [];

    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.onresize = resize;
    resize();

    // --- LOGIC FOR CREATING A BALL ---
    // Only the host actually runs this to add to the array
    function createBall(x, y, color) {
        const angle = Math.random() * Math.PI * 2;
        const speed = 2 + Math.random() * 5;
        return {
            x: x,
            y: y,
            vx: Math.cos(angle) * speed,
            vy: Math.sin(angle) * speed,
            radius: 10 + Math.random() * 15,
            color: color || `hsl(${Math.random() * 360}, 80%, 60%)`
        };
    }

    // --- NETWORKING ---
    function startHosting() {
        isHost = true;
        peer = new Peer(codeInput.value);
        peer.on('open', (id) => statusDiv.textContent = "Hosting: " + id);
        peer.on('connection', (c) => {
            conn = c;
            setupEvents();
        });
    }

    function joinRoom() {
        isHost = false;
        peer = new Peer(); 
        peer.on('open', () => {
            conn = peer.connect(codeInput.value);
            setupEvents();
        });
    }

    function setupEvents() {
        conn.on('open', () => {
            isConnected = true;
            statusDiv.textContent = "Connected!";
            statusDiv.style.color = "#10b981";
        });

        conn.on('data', (data) => {
            if (isHost && data.type === 'SPAWN_REQUEST') {
                // Host receives request from Peer and creates ball
                circles.push(createBall(data.x, data.y, '#3b82f6'));
            } else if (!isHost && data.type === 'SYNC') {
                // Peer receives the master list from Host
                circles = data.circles;
            }
        });
    }

    // --- INPUT ---
    canvas.addEventListener('mousedown', (e) => {
        if (!isConnected && !isHost) return;

        if (isHost) {
            // Host spawns directly
            circles.push(createBall(e.clientX, e.clientY, '#10b981'));
        } else if (conn && conn.open) {
            // Peer sends request to Host
            conn.send({ type: 'SPAWN_REQUEST', x: e.clientX, y: e.clientY });
        }
    });

    // --- GAME LOOP ---
    function update() {
        if (isHost) {
            // Move balls
            circles.forEach(c => {
                c.x += c.vx;
                c.y += c.vy;
                if (c.x + c.radius > canvas.width || c.x - c.radius < 0) c.vx *= -1;
                if (c.y + c.radius > canvas.height || c.y - c.radius < 0) c.vy *= -1;
            });

            // Broadcast to Peer
            if (isConnected && conn.open) {
                conn.send({ type: 'SYNC', circles: circles });
            }
        }

        // Render
        ctx.fillStyle = '#020617';
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        circles.forEach(c => {
            ctx.beginPath();
            ctx.arc(c.x, c.y, c.radius, 0, Math.PI * 2);
            ctx.fillStyle = c.color;
            ctx.fill();
            ctx.closePath();
        });

        requestAnimationFrame(update);
    }

    update();
</script>
</body>
</html>